module Jekyll
  class LevelTag < Liquid::Block
    # Use a hash to track counters per page (keyed by page URL)
    @@level_counters = {}  # Hash to track level numbers per page
    
    def initialize(tag_name, markup, tokens)
      super
      @attrs = parse_attributes(markup)
      # Counter will be set during render when we have page context
    end
    
    # Reset counter for a specific page
    def self.reset_counter(page_key = nil)
      if page_key
        @@level_counters[page_key] = 0
      else
        @@level_counters.clear
      end
    end
    
    # Get or initialize counter for a page
    def self.get_counter(page_key)
      @@level_counters[page_key] ||= 0
      @@level_counters[page_key] += 1
      # Return the incremented value (1, 2, 3...)
      @@level_counters[page_key]
    end

    def render(context)
      @context = context
      site = context.registers[:site]
      
      # Get page key for per-page counter (needed before we set up level variables)
      page = context.registers[:page]
      page_key = page && page['url'] ? page['url'] : 'default'
      
      # Get or increment counter for this page
      level_num = Jekyll::LevelTag.get_counter(page_key)
      @level_number = level_num  # Store for use in render_content
      
      # CRITICAL: Set level variables in context BEFORE calling super
      # When super renders the block content, {{ level.number }} will already be available
      level_data = {
        'number' => level_num,
        'title' => "Level #{level_num}",
        'subtitle' => @attrs['subtitle'] || @attrs[:subtitle] || ''
      }
      
      # Set in context environment BEFORE rendering block content
      context.environments[0] ||= {}
      context.environments[0]['level'] = level_data
      context.environments[0]['level_number'] = level_num.to_s
      context.environments[0]['level_subtitle'] = level_data['subtitle']
      
      # NOW call super - it will render with level variables already in context
      # This ensures {{ level.number }} renders correctly
      content = super
      
      # Use the SAME level_num from above (don't increment counter again!)
      # level_num and @level_number are already set from lines 38-39
      
      # For SPA view, we'll render as a section with ID
      # NOTE: Header is now generated by user in markdown content, not auto-generated here
      # This simplifies the logic and avoids regex-based stripping
      
      <<~HTML
        <div id="level-#{level_num}" class="level-section" data-level="#{level_num}">
          #{render_content(content, site)}
        </div>
      HTML
    end

    private

    def parse_attributes(markup)
      attrs = {}
      # Parse: number=1 title="Level 1" subtitle="Planning" file="db-mini-project-lv-1"
      markup.scan(/(\w+)=["']([^"']+)["']/) do |key, value|
        attrs[key] = value
      end
      # Parse unquoted numbers
      markup.scan(/(\w+)=(\d+)/) do |key, value|
        attrs[key] = value.to_i if key == 'number'
      end
      attrs
    end

    def render_content(content, site)
      # Process Liquid tags (like {% showme %}) then convert markdown
      begin
        # Use the level number from the outer render method (stored in @level_number)
        current_level_num = @level_number
        current_subtitle = @attrs['subtitle'] || @attrs[:subtitle] || ''
        
        # Ensure level number is set correctly (should be 1, 2, 3...)
        if current_level_num.nil? || current_level_num == 0
          Jekyll.logger.warn "LevelTag:", "Level number is nil or 0, using fallback of 1"
          current_level_num = 1
        end
        
        # Create a new Liquid context with level variables
        # We need a fresh context to avoid variable leakage between levels
        if @context
          # Create new context and copy parent's registers (site, page, etc.)
          context = Liquid::Context.new
          @context.registers.each do |key, value|
            context.registers[key] = value
          end
        else
          context = Liquid::Context.new
        end
        
        # Prepare level data
        level_data = {
          'number' => current_level_num,
          'title' => "Level #{current_level_num}",
          'subtitle' => current_subtitle
        }
        
        # CRITICAL: Set variables in the first environment BEFORE parsing/rendering
        # Liquid::Context initializes with environments = [{}], so [0] should exist
        # Set the variables directly in the first environment hash
        context.environments[0]['level'] = level_data
        context.environments[0]['level_number'] = current_level_num.to_s
        context.environments[0]['level_subtitle'] = current_subtitle
        
        # Also set as integers for numeric access
        context.environments[0]['level_number_int'] = current_level_num
        
        # Log for debugging
        Jekyll.logger.debug "LevelTag:", "Setting level.number = #{current_level_num} for subtitle: #{current_subtitle}"
        
        # Make all levels available for cross-referencing
        # Parse from all-levels.md to build dictionary with SPA anchor links
        levels_by_subtitle = {}
        
        # Determine lesson slug and SPA URL from page context
        page = @context.registers[:page] if @context
        lesson_slug = ''
        spa_url = '/all-levels-spa.html'
        
        if page
          # Try to get lesson slug from page data
          lesson_slug = page['lesson_slug'] || page.dig('lesson', 'slug') || ''
          
          # Infer from URL if not in page data
          if lesson_slug.empty? && page['url']
            url_parts = page['url'].split('/').reject(&:empty?)
            lesson_slug = url_parts.first if url_parts.any?
          end
          
          # Build SPA URL
          if lesson_slug && !lesson_slug.empty?
            spa_url = "/#{lesson_slug}/all-levels-spa.html"
          else
            spa_url = '/all-levels-spa.html'
          end
        end
        
        # Find all-levels.md file
        all_levels_file = nil
        if lesson_slug && !lesson_slug.empty?
          # Try lesson-specific path
          all_levels_file = File.join(site.source, '_lessons', lesson_slug, 'all-levels.md')
          all_levels_file = nil unless File.exist?(all_levels_file)
        end
        
        # Fallback to default path
        all_levels_file ||= File.join(site.source, '_levels', 'all-levels.md')
        all_levels_file = nil unless File.exist?(all_levels_file)
        
        # Parse from all-levels.md to build dictionary
        if all_levels_file && File.exist?(all_levels_file)
          file_content = File.read(all_levels_file, encoding: 'UTF-8')
          # Remove front matter if present
          if file_content.start_with?('---')
            parts = file_content.split(/^---\s*$/, 3)
            file_content = parts[2].strip if parts.length >= 3
          end
            
          # Parse level blocks to build dictionary
          # Use a different variable name to avoid conflicts with current_level_num
          pattern = /{%\s*level\s+([^%]+?)\s*%}(.*?){%\s*endlevel\s*%}/m
          cross_ref_level_num = 1
          file_content.scan(pattern) do |attrs_str, level_content|
            # Parse subtitle from attributes
            subtitle_match = attrs_str.match(/subtitle=["']([^"']+)["']/)
            if subtitle_match
              subtitle = subtitle_match[1]
              levels_by_subtitle[subtitle] = {
                'number' => cross_ref_level_num,
                'title' => "Level #{cross_ref_level_num}",
                'subtitle' => subtitle,
                'file' => "level-#{cross_ref_level_num}",
                'url' => "#{spa_url}#level-#{cross_ref_level_num}"  # SPA anchor link
              }
              cross_ref_level_num += 1
            end
          end
        end
        
        # Add cross-referencing data AFTER setting current level data
        # This ensures current level.number takes precedence
        context['levels_by_subtitle'] = levels_by_subtitle
        context['all_levels'] = levels_by_subtitle.values
        
        # NOW parse and render the template - level.number is already set in context
        # Verify variables are accessible before parsing
        test_template = Liquid::Template.parse("{{ level.number }}")
        test_output = test_template.render(context)
        Jekyll.logger.debug "LevelTag:", "Test render of {{ level.number }}: [#{test_output}] for level #{current_level_num}"
        
        # Debug: Check what content looks like before parsing
        content_sample = content.lines.first(3).join.chomp
        Jekyll.logger.debug "LevelTag:", "Content sample (first 3 lines): #{content_sample.inspect}"
        
        # Now parse and render the actual content
        template = Liquid::Template.parse(content)
        liquid_output = template.render(context)
        
        # Debug: Check if level.number was rendered correctly
        liquid_sample = liquid_output.lines.first(3).join.chomp
        Jekyll.logger.debug "LevelTag:", "Liquid output sample (first 3 lines): #{liquid_sample.inspect}"
        Jekyll.logger.debug "LevelTag:", "Rendered content includes level number: #{liquid_output.include?("Level #{current_level_num}")}"
      rescue Liquid::SyntaxError => e
        Jekyll.logger.warn "LevelTag:", "Liquid parsing error: #{e.message}"
        liquid_output = content
      end
      
      # No regex-based header stripping - users write their own headers in markdown
      # This keeps the logic simple and predictable
      
      converter = site.find_converter_instance(Jekyll::Converters::Markdown)
      converter.convert(liquid_output)
    end
  end
end

Liquid::Template.register_tag('level', Jekyll::LevelTag)

